// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: match.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_match_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_match_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_match_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_match_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_match_2eproto;
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
struct CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class CreateRoomTCPRequest;
struct CreateRoomTCPRequestDefaultTypeInternal;
extern CreateRoomTCPRequestDefaultTypeInternal _CreateRoomTCPRequest_default_instance_;
class CreateRoomTCPResponse;
struct CreateRoomTCPResponseDefaultTypeInternal;
extern CreateRoomTCPResponseDefaultTypeInternal _CreateRoomTCPResponse_default_instance_;
class EnterRoomRequest;
struct EnterRoomRequestDefaultTypeInternal;
extern EnterRoomRequestDefaultTypeInternal _EnterRoomRequest_default_instance_;
class EnterRoomResponse;
struct EnterRoomResponseDefaultTypeInternal;
extern EnterRoomResponseDefaultTypeInternal _EnterRoomResponse_default_instance_;
class GetRoomListRequest;
struct GetRoomListRequestDefaultTypeInternal;
extern GetRoomListRequestDefaultTypeInternal _GetRoomListRequest_default_instance_;
class GetRoomListResponse;
struct GetRoomListResponseDefaultTypeInternal;
extern GetRoomListResponseDefaultTypeInternal _GetRoomListResponse_default_instance_;
class LeaveRoomRequest;
struct LeaveRoomRequestDefaultTypeInternal;
extern LeaveRoomRequestDefaultTypeInternal _LeaveRoomRequest_default_instance_;
class PUser;
struct PUserDefaultTypeInternal;
extern PUserDefaultTypeInternal _PUser_default_instance_;
class RegistServerRequest;
struct RegistServerRequestDefaultTypeInternal;
extern RegistServerRequestDefaultTypeInternal _RegistServerRequest_default_instance_;
class RegistServerResponse;
struct RegistServerResponseDefaultTypeInternal;
extern RegistServerResponseDefaultTypeInternal _RegistServerResponse_default_instance_;
class RemoveRoomTCPRequest;
struct RemoveRoomTCPRequestDefaultTypeInternal;
extern RemoveRoomTCPRequestDefaultTypeInternal _RemoveRoomTCPRequest_default_instance_;
class RemoveServerRequest;
struct RemoveServerRequestDefaultTypeInternal;
extern RemoveServerRequestDefaultTypeInternal _RemoveServerRequest_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RoomList;
struct RoomListDefaultTypeInternal;
extern RoomListDefaultTypeInternal _RoomList_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class ServerInfoList;
struct ServerInfoListDefaultTypeInternal;
extern ServerInfoListDefaultTypeInternal _ServerInfoList_default_instance_;
class StartGameRequest;
struct StartGameRequestDefaultTypeInternal;
extern StartGameRequestDefaultTypeInternal _StartGameRequest_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CreateRoomRequest* Arena::CreateMaybeMessage<::CreateRoomRequest>(Arena*);
template<> ::CreateRoomResponse* Arena::CreateMaybeMessage<::CreateRoomResponse>(Arena*);
template<> ::CreateRoomTCPRequest* Arena::CreateMaybeMessage<::CreateRoomTCPRequest>(Arena*);
template<> ::CreateRoomTCPResponse* Arena::CreateMaybeMessage<::CreateRoomTCPResponse>(Arena*);
template<> ::EnterRoomRequest* Arena::CreateMaybeMessage<::EnterRoomRequest>(Arena*);
template<> ::EnterRoomResponse* Arena::CreateMaybeMessage<::EnterRoomResponse>(Arena*);
template<> ::GetRoomListRequest* Arena::CreateMaybeMessage<::GetRoomListRequest>(Arena*);
template<> ::GetRoomListResponse* Arena::CreateMaybeMessage<::GetRoomListResponse>(Arena*);
template<> ::LeaveRoomRequest* Arena::CreateMaybeMessage<::LeaveRoomRequest>(Arena*);
template<> ::PUser* Arena::CreateMaybeMessage<::PUser>(Arena*);
template<> ::RegistServerRequest* Arena::CreateMaybeMessage<::RegistServerRequest>(Arena*);
template<> ::RegistServerResponse* Arena::CreateMaybeMessage<::RegistServerResponse>(Arena*);
template<> ::RemoveRoomTCPRequest* Arena::CreateMaybeMessage<::RemoveRoomTCPRequest>(Arena*);
template<> ::RemoveServerRequest* Arena::CreateMaybeMessage<::RemoveServerRequest>(Arena*);
template<> ::Request* Arena::CreateMaybeMessage<::Request>(Arena*);
template<> ::Response* Arena::CreateMaybeMessage<::Response>(Arena*);
template<> ::RoomInfo* Arena::CreateMaybeMessage<::RoomInfo>(Arena*);
template<> ::RoomList* Arena::CreateMaybeMessage<::RoomList>(Arena*);
template<> ::ServerInfo* Arena::CreateMaybeMessage<::ServerInfo>(Arena*);
template<> ::ServerInfoList* Arena::CreateMaybeMessage<::ServerInfoList>(Arena*);
template<> ::StartGameRequest* Arena::CreateMaybeMessage<::StartGameRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerInfo& from) {
    ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kRegionFieldNumber = 3,
    kRoomListFieldNumber = 4,
    kPortFieldNumber = 2,
  };
  // string host = 1;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // .RoomList roomList = 4;
  bool has_roomlist() const;
  private:
  bool _internal_has_roomlist() const;
  public:
  void clear_roomlist();
  const ::RoomList& roomlist() const;
  PROTOBUF_NODISCARD ::RoomList* release_roomlist();
  ::RoomList* mutable_roomlist();
  void set_allocated_roomlist(::RoomList* roomlist);
  private:
  const ::RoomList& _internal_roomlist() const;
  ::RoomList* _internal_mutable_roomlist();
  public:
  void unsafe_arena_set_allocated_roomlist(
      ::RoomList* roomlist);
  ::RoomList* unsafe_arena_release_roomlist();

  // uint32 port = 2;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::RoomList* roomlist_;
    uint32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RegistServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegistServerRequest) */ {
 public:
  inline RegistServerRequest() : RegistServerRequest(nullptr) {}
  ~RegistServerRequest() override;
  explicit PROTOBUF_CONSTEXPR RegistServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistServerRequest(const RegistServerRequest& from);
  RegistServerRequest(RegistServerRequest&& from) noexcept
    : RegistServerRequest() {
    *this = ::std::move(from);
  }

  inline RegistServerRequest& operator=(const RegistServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistServerRequest& operator=(RegistServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistServerRequest* internal_default_instance() {
    return reinterpret_cast<const RegistServerRequest*>(
               &_RegistServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegistServerRequest& a, RegistServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistServerRequest& from) {
    RegistServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegistServerRequest";
  }
  protected:
  explicit RegistServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfoFieldNumber = 1,
  };
  // .ServerInfo serverInfo = 1;
  bool has_serverinfo() const;
  private:
  bool _internal_has_serverinfo() const;
  public:
  void clear_serverinfo();
  const ::ServerInfo& serverinfo() const;
  PROTOBUF_NODISCARD ::ServerInfo* release_serverinfo();
  ::ServerInfo* mutable_serverinfo();
  void set_allocated_serverinfo(::ServerInfo* serverinfo);
  private:
  const ::ServerInfo& _internal_serverinfo() const;
  ::ServerInfo* _internal_mutable_serverinfo();
  public:
  void unsafe_arena_set_allocated_serverinfo(
      ::ServerInfo* serverinfo);
  ::ServerInfo* unsafe_arena_release_serverinfo();

  // @@protoc_insertion_point(class_scope:RegistServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerInfo* serverinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RegistServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegistServerResponse) */ {
 public:
  inline RegistServerResponse() : RegistServerResponse(nullptr) {}
  ~RegistServerResponse() override;
  explicit PROTOBUF_CONSTEXPR RegistServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistServerResponse(const RegistServerResponse& from);
  RegistServerResponse(RegistServerResponse&& from) noexcept
    : RegistServerResponse() {
    *this = ::std::move(from);
  }

  inline RegistServerResponse& operator=(const RegistServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistServerResponse& operator=(RegistServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistServerResponse* internal_default_instance() {
    return reinterpret_cast<const RegistServerResponse*>(
               &_RegistServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegistServerResponse& a, RegistServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistServerResponse& from) {
    RegistServerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegistServerResponse";
  }
  protected:
  explicit RegistServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kServerIdFieldNumber = 2,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // uint32 serverId = 2;
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RegistServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    uint32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RemoveServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoveServerRequest) */ {
 public:
  inline RemoveServerRequest() : RemoveServerRequest(nullptr) {}
  ~RemoveServerRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveServerRequest(const RemoveServerRequest& from);
  RemoveServerRequest(RemoveServerRequest&& from) noexcept
    : RemoveServerRequest() {
    *this = ::std::move(from);
  }

  inline RemoveServerRequest& operator=(const RemoveServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveServerRequest& operator=(RemoveServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveServerRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveServerRequest*>(
               &_RemoveServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RemoveServerRequest& a, RemoveServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveServerRequest& from) {
    RemoveServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoveServerRequest";
  }
  protected:
  explicit RemoveServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 2,
    kServerIdFieldNumber = 1,
  };
  // string region = 2;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // uint32 serverId = 1;
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoveServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    uint32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class ServerInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfoList) */ {
 public:
  inline ServerInfoList() : ServerInfoList(nullptr) {}
  ~ServerInfoList() override;
  explicit PROTOBUF_CONSTEXPR ServerInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfoList(const ServerInfoList& from);
  ServerInfoList(ServerInfoList&& from) noexcept
    : ServerInfoList() {
    *this = ::std::move(from);
  }

  inline ServerInfoList& operator=(const ServerInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfoList& operator=(ServerInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfoList* internal_default_instance() {
    return reinterpret_cast<const ServerInfoList*>(
               &_ServerInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerInfoList& a, ServerInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerInfoList& from) {
    ServerInfoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfoList";
  }
  protected:
  explicit ServerInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfosFieldNumber = 1,
  };
  // repeated .ServerInfo serverInfos = 1;
  int serverinfos_size() const;
  private:
  int _internal_serverinfos_size() const;
  public:
  void clear_serverinfos();
  ::ServerInfo* mutable_serverinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo >*
      mutable_serverinfos();
  private:
  const ::ServerInfo& _internal_serverinfos(int index) const;
  ::ServerInfo* _internal_add_serverinfos();
  public:
  const ::ServerInfo& serverinfos(int index) const;
  ::ServerInfo* add_serverinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo >&
      serverinfos() const;

  // @@protoc_insertion_point(class_scope:ServerInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo > serverinfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class PUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PUser) */ {
 public:
  inline PUser() : PUser(nullptr) {}
  ~PUser() override;
  explicit PROTOBUF_CONSTEXPR PUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PUser(const PUser& from);
  PUser(PUser&& from) noexcept
    : PUser() {
    *this = ::std::move(from);
  }

  inline PUser& operator=(const PUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline PUser& operator=(PUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const PUser* internal_default_instance() {
    return reinterpret_cast<const PUser*>(
               &_PUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PUser& a, PUser& b) {
    a.Swap(&b);
  }
  inline void Swap(PUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PUser& from) {
    PUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PUser";
  }
  protected:
  explicit PUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRegionFieldNumber = 3,
    kAidxFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // uint64 aidx = 1;
  void clear_aidx();
  uint64_t aidx() const;
  void set_aidx(uint64_t value);
  private:
  uint64_t _internal_aidx() const;
  void _internal_set_aidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    uint64_t aidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomInfo& from) {
    RoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kHostAidxFieldNumber = 1,
    kMapIdFieldNumber = 3,
    kMinMemberCountFieldNumber = 4,
    kMaxMemberCountFieldNumber = 5,
    kNowMemberCountFieldNumber = 6,
    kRoomIdFieldNumber = 7,
    kLockedFieldNumber = 8,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // uint64 hostAidx = 1;
  void clear_hostaidx();
  uint64_t hostaidx() const;
  void set_hostaidx(uint64_t value);
  private:
  uint64_t _internal_hostaidx() const;
  void _internal_set_hostaidx(uint64_t value);
  public:

  // uint32 mapId = 3;
  void clear_mapid();
  uint32_t mapid() const;
  void set_mapid(uint32_t value);
  private:
  uint32_t _internal_mapid() const;
  void _internal_set_mapid(uint32_t value);
  public:

  // uint32 minMemberCount = 4;
  void clear_minmembercount();
  uint32_t minmembercount() const;
  void set_minmembercount(uint32_t value);
  private:
  uint32_t _internal_minmembercount() const;
  void _internal_set_minmembercount(uint32_t value);
  public:

  // uint32 maxMemberCount = 5;
  void clear_maxmembercount();
  uint32_t maxmembercount() const;
  void set_maxmembercount(uint32_t value);
  private:
  uint32_t _internal_maxmembercount() const;
  void _internal_set_maxmembercount(uint32_t value);
  public:

  // uint32 nowMemberCount = 6;
  void clear_nowmembercount();
  uint32_t nowmembercount() const;
  void set_nowmembercount(uint32_t value);
  private:
  uint32_t _internal_nowmembercount() const;
  void _internal_set_nowmembercount(uint32_t value);
  public:

  // uint64 roomId = 7;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // bool locked = 8;
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    uint64_t hostaidx_;
    uint32_t mapid_;
    uint32_t minmembercount_;
    uint32_t maxmembercount_;
    uint32_t nowmembercount_;
    uint64_t roomid_;
    bool locked_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class GetRoomListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetRoomListRequest) */ {
 public:
  inline GetRoomListRequest() : GetRoomListRequest(nullptr) {}
  ~GetRoomListRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRoomListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoomListRequest(const GetRoomListRequest& from);
  GetRoomListRequest(GetRoomListRequest&& from) noexcept
    : GetRoomListRequest() {
    *this = ::std::move(from);
  }

  inline GetRoomListRequest& operator=(const GetRoomListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoomListRequest& operator=(GetRoomListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoomListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoomListRequest* internal_default_instance() {
    return reinterpret_cast<const GetRoomListRequest*>(
               &_GetRoomListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetRoomListRequest& a, GetRoomListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoomListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoomListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoomListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoomListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoomListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoomListRequest& from) {
    GetRoomListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoomListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetRoomListRequest";
  }
  protected:
  explicit GetRoomListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
  };
  // string region = 1;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:GetRoomListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  ~CreateRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomRequest& from) {
    CreateRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kTitleFieldNumber = 3,
    kHostAidxFieldNumber = 2,
    kMapIdFieldNumber = 4,
    kMinMemberCountFieldNumber = 5,
    kMaxMemberCountFieldNumber = 6,
  };
  // string region = 1;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // uint64 hostAidx = 2;
  void clear_hostaidx();
  uint64_t hostaidx() const;
  void set_hostaidx(uint64_t value);
  private:
  uint64_t _internal_hostaidx() const;
  void _internal_set_hostaidx(uint64_t value);
  public:

  // uint32 mapId = 4;
  void clear_mapid();
  uint32_t mapid() const;
  void set_mapid(uint32_t value);
  private:
  uint32_t _internal_mapid() const;
  void _internal_set_mapid(uint32_t value);
  public:

  // uint32 minMemberCount = 5;
  void clear_minmembercount();
  uint32_t minmembercount() const;
  void set_minmembercount(uint32_t value);
  private:
  uint32_t _internal_minmembercount() const;
  void _internal_set_minmembercount(uint32_t value);
  public:

  // uint32 maxMemberCount = 6;
  void clear_maxmembercount();
  uint32_t maxmembercount() const;
  void set_maxmembercount(uint32_t value);
  private:
  uint32_t _internal_maxmembercount() const;
  void _internal_set_maxmembercount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    uint64_t hostaidx_;
    uint32_t mapid_;
    uint32_t minmembercount_;
    uint32_t maxmembercount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateRoomResponse) */ {
 public:
  inline CreateRoomResponse() : CreateRoomResponse(nullptr) {}
  ~CreateRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomResponse(const CreateRoomResponse& from);
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomResponse& from) {
    CreateRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateRoomResponse";
  }
  protected:
  explicit CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // uint64 roomId = 1;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CreateRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomTCPRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateRoomTCPRequest) */ {
 public:
  inline CreateRoomTCPRequest() : CreateRoomTCPRequest(nullptr) {}
  ~CreateRoomTCPRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomTCPRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomTCPRequest(const CreateRoomTCPRequest& from);
  CreateRoomTCPRequest(CreateRoomTCPRequest&& from) noexcept
    : CreateRoomTCPRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomTCPRequest& operator=(const CreateRoomTCPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomTCPRequest& operator=(CreateRoomTCPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomTCPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomTCPRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomTCPRequest*>(
               &_CreateRoomTCPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateRoomTCPRequest& a, CreateRoomTCPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomTCPRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomTCPRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomTCPRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomTCPRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomTCPRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomTCPRequest& from) {
    CreateRoomTCPRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomTCPRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateRoomTCPRequest";
  }
  protected:
  explicit CreateRoomTCPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kRoomIdFieldNumber = 3,
    kTcpRoomIdFieldNumber = 4,
    kServerIdFieldNumber = 2,
  };
  // string region = 1;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // uint64 roomId = 3;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // uint64 tcpRoomId = 4;
  void clear_tcproomid();
  uint64_t tcproomid() const;
  void set_tcproomid(uint64_t value);
  private:
  uint64_t _internal_tcproomid() const;
  void _internal_set_tcproomid(uint64_t value);
  public:

  // uint32 serverId = 2;
  void clear_serverid();
  uint32_t serverid() const;
  void set_serverid(uint32_t value);
  private:
  uint32_t _internal_serverid() const;
  void _internal_set_serverid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CreateRoomTCPRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    uint64_t roomid_;
    uint64_t tcproomid_;
    uint32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomTCPResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateRoomTCPResponse) */ {
 public:
  inline CreateRoomTCPResponse() : CreateRoomTCPResponse(nullptr) {}
  ~CreateRoomTCPResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomTCPResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomTCPResponse(const CreateRoomTCPResponse& from);
  CreateRoomTCPResponse(CreateRoomTCPResponse&& from) noexcept
    : CreateRoomTCPResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomTCPResponse& operator=(const CreateRoomTCPResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomTCPResponse& operator=(CreateRoomTCPResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomTCPResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomTCPResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomTCPResponse*>(
               &_CreateRoomTCPResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateRoomTCPResponse& a, CreateRoomTCPResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomTCPResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomTCPResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomTCPResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomTCPResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomTCPResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomTCPResponse& from) {
    CreateRoomTCPResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomTCPResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CreateRoomTCPResponse";
  }
  protected:
  explicit CreateRoomTCPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kHostAidxFieldNumber = 1,
    kMapIdFieldNumber = 3,
    kMinMemberCountFieldNumber = 4,
    kRoomIdFieldNumber = 6,
    kTcpRoomIdFieldNumber = 7,
    kMaxMemberCountFieldNumber = 5,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // uint64 hostAidx = 1;
  void clear_hostaidx();
  uint64_t hostaidx() const;
  void set_hostaidx(uint64_t value);
  private:
  uint64_t _internal_hostaidx() const;
  void _internal_set_hostaidx(uint64_t value);
  public:

  // uint32 mapId = 3;
  void clear_mapid();
  uint32_t mapid() const;
  void set_mapid(uint32_t value);
  private:
  uint32_t _internal_mapid() const;
  void _internal_set_mapid(uint32_t value);
  public:

  // uint32 minMemberCount = 4;
  void clear_minmembercount();
  uint32_t minmembercount() const;
  void set_minmembercount(uint32_t value);
  private:
  uint32_t _internal_minmembercount() const;
  void _internal_set_minmembercount(uint32_t value);
  public:

  // uint64 roomId = 6;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // uint64 tcpRoomId = 7;
  void clear_tcproomid();
  uint64_t tcproomid() const;
  void set_tcproomid(uint64_t value);
  private:
  uint64_t _internal_tcproomid() const;
  void _internal_set_tcproomid(uint64_t value);
  public:

  // uint32 maxMemberCount = 5;
  void clear_maxmembercount();
  uint32_t maxmembercount() const;
  void set_maxmembercount(uint32_t value);
  private:
  uint32_t _internal_maxmembercount() const;
  void _internal_set_maxmembercount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CreateRoomTCPResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    uint64_t hostaidx_;
    uint32_t mapid_;
    uint32_t minmembercount_;
    uint64_t roomid_;
    uint64_t tcproomid_;
    uint32_t maxmembercount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RemoveRoomTCPRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoveRoomTCPRequest) */ {
 public:
  inline RemoveRoomTCPRequest() : RemoveRoomTCPRequest(nullptr) {}
  ~RemoveRoomTCPRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveRoomTCPRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRoomTCPRequest(const RemoveRoomTCPRequest& from);
  RemoveRoomTCPRequest(RemoveRoomTCPRequest&& from) noexcept
    : RemoveRoomTCPRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRoomTCPRequest& operator=(const RemoveRoomTCPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRoomTCPRequest& operator=(RemoveRoomTCPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRoomTCPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRoomTCPRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRoomTCPRequest*>(
               &_RemoveRoomTCPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RemoveRoomTCPRequest& a, RemoveRoomTCPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRoomTCPRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRoomTCPRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRoomTCPRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRoomTCPRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRoomTCPRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveRoomTCPRequest& from) {
    RemoveRoomTCPRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRoomTCPRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoveRoomTCPRequest";
  }
  protected:
  explicit RemoveRoomTCPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // uint64 roomId = 1;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoveRoomTCPRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EnterRoomRequest) */ {
 public:
  inline EnterRoomRequest() : EnterRoomRequest(nullptr) {}
  ~EnterRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR EnterRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomRequest(const EnterRoomRequest& from);
  EnterRoomRequest(EnterRoomRequest&& from) noexcept
    : EnterRoomRequest() {
    *this = ::std::move(from);
  }

  inline EnterRoomRequest& operator=(const EnterRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomRequest& operator=(EnterRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomRequest* internal_default_instance() {
    return reinterpret_cast<const EnterRoomRequest*>(
               &_EnterRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EnterRoomRequest& a, EnterRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnterRoomRequest& from) {
    EnterRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EnterRoomRequest";
  }
  protected:
  explicit EnterRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRegionFieldNumber = 3,
    kAidxFieldNumber = 1,
    kRoomIdFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // uint64 aidx = 1;
  void clear_aidx();
  uint64_t aidx() const;
  void set_aidx(uint64_t value);
  private:
  uint64_t _internal_aidx() const;
  void _internal_set_aidx(uint64_t value);
  public:

  // uint64 roomId = 4;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:EnterRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    uint64_t aidx_;
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EnterRoomResponse) */ {
 public:
  inline EnterRoomResponse() : EnterRoomResponse(nullptr) {}
  ~EnterRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR EnterRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomResponse(const EnterRoomResponse& from);
  EnterRoomResponse(EnterRoomResponse&& from) noexcept
    : EnterRoomResponse() {
    *this = ::std::move(from);
  }

  inline EnterRoomResponse& operator=(const EnterRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomResponse& operator=(EnterRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomResponse* internal_default_instance() {
    return reinterpret_cast<const EnterRoomResponse*>(
               &_EnterRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EnterRoomResponse& a, EnterRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnterRoomResponse& from) {
    EnterRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EnterRoomResponse";
  }
  protected:
  explicit EnterRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kHostFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kPortFieldNumber = 4,
    kTcpRoomIdFieldNumber = 5,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 port = 4;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // uint64 tcpRoomId = 5;
  void clear_tcproomid();
  uint64_t tcproomid() const;
  void set_tcproomid(uint64_t value);
  private:
  uint64_t _internal_tcproomid() const;
  void _internal_set_tcproomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:EnterRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    bool success_;
    uint32_t port_;
    uint64_t tcproomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LeaveRoomRequest) */ {
 public:
  inline LeaveRoomRequest() : LeaveRoomRequest(nullptr) {}
  ~LeaveRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR LeaveRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomRequest(const LeaveRoomRequest& from);
  LeaveRoomRequest(LeaveRoomRequest&& from) noexcept
    : LeaveRoomRequest() {
    *this = ::std::move(from);
  }

  inline LeaveRoomRequest& operator=(const LeaveRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomRequest& operator=(LeaveRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomRequest*>(
               &_LeaveRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LeaveRoomRequest& a, LeaveRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaveRoomRequest& from) {
    LeaveRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LeaveRoomRequest";
  }
  protected:
  explicit LeaveRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAidxFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // uint64 aidx = 1;
  void clear_aidx();
  uint64_t aidx() const;
  void set_aidx(uint64_t value);
  private:
  uint64_t _internal_aidx() const;
  void _internal_set_aidx(uint64_t value);
  public:

  // uint64 roomId = 2;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:LeaveRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t aidx_;
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class StartGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StartGameRequest) */ {
 public:
  inline StartGameRequest() : StartGameRequest(nullptr) {}
  ~StartGameRequest() override;
  explicit PROTOBUF_CONSTEXPR StartGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartGameRequest(const StartGameRequest& from);
  StartGameRequest(StartGameRequest&& from) noexcept
    : StartGameRequest() {
    *this = ::std::move(from);
  }

  inline StartGameRequest& operator=(const StartGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGameRequest& operator=(StartGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartGameRequest* internal_default_instance() {
    return reinterpret_cast<const StartGameRequest*>(
               &_StartGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StartGameRequest& a, StartGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartGameRequest& from) {
    StartGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartGameRequest";
  }
  protected:
  explicit StartGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostAidxFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // uint64 hostAidx = 1;
  void clear_hostaidx();
  uint64_t hostaidx() const;
  void set_hostaidx(uint64_t value);
  private:
  uint64_t _internal_hostaidx() const;
  void _internal_set_hostaidx(uint64_t value);
  public:

  // uint64 roomId = 2;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StartGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hostaidx_;
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class GetRoomListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetRoomListResponse) */ {
 public:
  inline GetRoomListResponse() : GetRoomListResponse(nullptr) {}
  ~GetRoomListResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRoomListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoomListResponse(const GetRoomListResponse& from);
  GetRoomListResponse(GetRoomListResponse&& from) noexcept
    : GetRoomListResponse() {
    *this = ::std::move(from);
  }

  inline GetRoomListResponse& operator=(const GetRoomListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoomListResponse& operator=(GetRoomListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoomListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoomListResponse* internal_default_instance() {
    return reinterpret_cast<const GetRoomListResponse*>(
               &_GetRoomListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetRoomListResponse& a, GetRoomListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoomListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoomListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoomListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoomListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoomListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoomListResponse& from) {
    GetRoomListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoomListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetRoomListResponse";
  }
  protected:
  explicit GetRoomListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfosFieldNumber = 1,
  };
  // repeated .RoomInfo roomInfos = 1;
  int roominfos_size() const;
  private:
  int _internal_roominfos_size() const;
  public:
  void clear_roominfos();
  ::RoomInfo* mutable_roominfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >*
      mutable_roominfos();
  private:
  const ::RoomInfo& _internal_roominfos(int index) const;
  ::RoomInfo* _internal_add_roominfos();
  public:
  const ::RoomInfo& roominfos(int index) const;
  ::RoomInfo* add_roominfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >&
      roominfos() const;

  // @@protoc_insertion_point(class_scope:GetRoomListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo > roominfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// -------------------------------------------------------------------

class RoomList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomList) */ {
 public:
  inline RoomList() : RoomList(nullptr) {}
  ~RoomList() override;
  explicit PROTOBUF_CONSTEXPR RoomList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomList(const RoomList& from);
  RoomList(RoomList&& from) noexcept
    : RoomList() {
    *this = ::std::move(from);
  }

  inline RoomList& operator=(const RoomList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomList& operator=(RoomList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomList* internal_default_instance() {
    return reinterpret_cast<const RoomList*>(
               &_RoomList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RoomList& a, RoomList& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomList& from) {
    RoomList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomList";
  }
  protected:
  explicit RoomList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfosFieldNumber = 1,
  };
  // repeated .RoomInfo roomInfos = 1;
  int roominfos_size() const;
  private:
  int _internal_roominfos_size() const;
  public:
  void clear_roominfos();
  ::RoomInfo* mutable_roominfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >*
      mutable_roominfos();
  private:
  const ::RoomInfo& _internal_roominfos(int index) const;
  ::RoomInfo* _internal_add_roominfos();
  public:
  const ::RoomInfo& roominfos(int index) const;
  ::RoomInfo* add_roominfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >&
      roominfos() const;

  // @@protoc_insertion_point(class_scope:RoomList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo > roominfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_match_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// -------------------------------------------------------------------

// Response

// bool result = 1;
inline void Response::clear_result() {
  _impl_.result_ = false;
}
inline bool Response::_internal_result() const {
  return _impl_.result_;
}
inline bool Response::result() const {
  // @@protoc_insertion_point(field_get:Response.result)
  return _internal_result();
}
inline void Response::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void Response::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Response.result)
}

// -------------------------------------------------------------------

// ServerInfo

// string host = 1;
inline void ServerInfo::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ServerInfo::host() const {
  // @@protoc_insertion_point(field_get:ServerInfo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.host)
}
inline std::string* ServerInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:ServerInfo.host)
  return _s;
}
inline const std::string& ServerInfo::_internal_host() const {
  return _impl_.host_.Get();
}
inline void ServerInfo::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_host() {
  // @@protoc_insertion_point(field_release:ServerInfo.host)
  return _impl_.host_.Release();
}
inline void ServerInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.host)
}

// uint32 port = 2;
inline void ServerInfo::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t ServerInfo::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:ServerInfo.port)
  return _internal_port();
}
inline void ServerInfo::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void ServerInfo::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ServerInfo.port)
}

// string region = 3;
inline void ServerInfo::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& ServerInfo::region() const {
  // @@protoc_insertion_point(field_get:ServerInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.region)
}
inline std::string* ServerInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:ServerInfo.region)
  return _s;
}
inline const std::string& ServerInfo::_internal_region() const {
  return _impl_.region_.Get();
}
inline void ServerInfo::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_region() {
  // @@protoc_insertion_point(field_release:ServerInfo.region)
  return _impl_.region_.Release();
}
inline void ServerInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.region)
}

// .RoomList roomList = 4;
inline bool ServerInfo::_internal_has_roomlist() const {
  return this != internal_default_instance() && _impl_.roomlist_ != nullptr;
}
inline bool ServerInfo::has_roomlist() const {
  return _internal_has_roomlist();
}
inline void ServerInfo::clear_roomlist() {
  if (GetArenaForAllocation() == nullptr && _impl_.roomlist_ != nullptr) {
    delete _impl_.roomlist_;
  }
  _impl_.roomlist_ = nullptr;
}
inline const ::RoomList& ServerInfo::_internal_roomlist() const {
  const ::RoomList* p = _impl_.roomlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::RoomList&>(
      ::_RoomList_default_instance_);
}
inline const ::RoomList& ServerInfo::roomlist() const {
  // @@protoc_insertion_point(field_get:ServerInfo.roomList)
  return _internal_roomlist();
}
inline void ServerInfo::unsafe_arena_set_allocated_roomlist(
    ::RoomList* roomlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roomlist_);
  }
  _impl_.roomlist_ = roomlist;
  if (roomlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerInfo.roomList)
}
inline ::RoomList* ServerInfo::release_roomlist() {
  
  ::RoomList* temp = _impl_.roomlist_;
  _impl_.roomlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RoomList* ServerInfo::unsafe_arena_release_roomlist() {
  // @@protoc_insertion_point(field_release:ServerInfo.roomList)
  
  ::RoomList* temp = _impl_.roomlist_;
  _impl_.roomlist_ = nullptr;
  return temp;
}
inline ::RoomList* ServerInfo::_internal_mutable_roomlist() {
  
  if (_impl_.roomlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoomList>(GetArenaForAllocation());
    _impl_.roomlist_ = p;
  }
  return _impl_.roomlist_;
}
inline ::RoomList* ServerInfo::mutable_roomlist() {
  ::RoomList* _msg = _internal_mutable_roomlist();
  // @@protoc_insertion_point(field_mutable:ServerInfo.roomList)
  return _msg;
}
inline void ServerInfo::set_allocated_roomlist(::RoomList* roomlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roomlist_;
  }
  if (roomlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roomlist);
    if (message_arena != submessage_arena) {
      roomlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roomlist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.roomlist_ = roomlist;
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.roomList)
}

// -------------------------------------------------------------------

// RegistServerRequest

// .ServerInfo serverInfo = 1;
inline bool RegistServerRequest::_internal_has_serverinfo() const {
  return this != internal_default_instance() && _impl_.serverinfo_ != nullptr;
}
inline bool RegistServerRequest::has_serverinfo() const {
  return _internal_has_serverinfo();
}
inline void RegistServerRequest::clear_serverinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.serverinfo_ != nullptr) {
    delete _impl_.serverinfo_;
  }
  _impl_.serverinfo_ = nullptr;
}
inline const ::ServerInfo& RegistServerRequest::_internal_serverinfo() const {
  const ::ServerInfo* p = _impl_.serverinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerInfo&>(
      ::_ServerInfo_default_instance_);
}
inline const ::ServerInfo& RegistServerRequest::serverinfo() const {
  // @@protoc_insertion_point(field_get:RegistServerRequest.serverInfo)
  return _internal_serverinfo();
}
inline void RegistServerRequest::unsafe_arena_set_allocated_serverinfo(
    ::ServerInfo* serverinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serverinfo_);
  }
  _impl_.serverinfo_ = serverinfo;
  if (serverinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegistServerRequest.serverInfo)
}
inline ::ServerInfo* RegistServerRequest::release_serverinfo() {
  
  ::ServerInfo* temp = _impl_.serverinfo_;
  _impl_.serverinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerInfo* RegistServerRequest::unsafe_arena_release_serverinfo() {
  // @@protoc_insertion_point(field_release:RegistServerRequest.serverInfo)
  
  ::ServerInfo* temp = _impl_.serverinfo_;
  _impl_.serverinfo_ = nullptr;
  return temp;
}
inline ::ServerInfo* RegistServerRequest::_internal_mutable_serverinfo() {
  
  if (_impl_.serverinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerInfo>(GetArenaForAllocation());
    _impl_.serverinfo_ = p;
  }
  return _impl_.serverinfo_;
}
inline ::ServerInfo* RegistServerRequest::mutable_serverinfo() {
  ::ServerInfo* _msg = _internal_mutable_serverinfo();
  // @@protoc_insertion_point(field_mutable:RegistServerRequest.serverInfo)
  return _msg;
}
inline void RegistServerRequest::set_allocated_serverinfo(::ServerInfo* serverinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.serverinfo_;
  }
  if (serverinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serverinfo);
    if (message_arena != submessage_arena) {
      serverinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serverinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serverinfo_ = serverinfo;
  // @@protoc_insertion_point(field_set_allocated:RegistServerRequest.serverInfo)
}

// -------------------------------------------------------------------

// RegistServerResponse

// bool result = 1;
inline void RegistServerResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool RegistServerResponse::_internal_result() const {
  return _impl_.result_;
}
inline bool RegistServerResponse::result() const {
  // @@protoc_insertion_point(field_get:RegistServerResponse.result)
  return _internal_result();
}
inline void RegistServerResponse::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void RegistServerResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:RegistServerResponse.result)
}

// uint32 serverId = 2;
inline void RegistServerResponse::clear_serverid() {
  _impl_.serverid_ = 0u;
}
inline uint32_t RegistServerResponse::_internal_serverid() const {
  return _impl_.serverid_;
}
inline uint32_t RegistServerResponse::serverid() const {
  // @@protoc_insertion_point(field_get:RegistServerResponse.serverId)
  return _internal_serverid();
}
inline void RegistServerResponse::_internal_set_serverid(uint32_t value) {
  
  _impl_.serverid_ = value;
}
inline void RegistServerResponse::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:RegistServerResponse.serverId)
}

// -------------------------------------------------------------------

// RemoveServerRequest

// uint32 serverId = 1;
inline void RemoveServerRequest::clear_serverid() {
  _impl_.serverid_ = 0u;
}
inline uint32_t RemoveServerRequest::_internal_serverid() const {
  return _impl_.serverid_;
}
inline uint32_t RemoveServerRequest::serverid() const {
  // @@protoc_insertion_point(field_get:RemoveServerRequest.serverId)
  return _internal_serverid();
}
inline void RemoveServerRequest::_internal_set_serverid(uint32_t value) {
  
  _impl_.serverid_ = value;
}
inline void RemoveServerRequest::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:RemoveServerRequest.serverId)
}

// string region = 2;
inline void RemoveServerRequest::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& RemoveServerRequest::region() const {
  // @@protoc_insertion_point(field_get:RemoveServerRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveServerRequest::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoveServerRequest.region)
}
inline std::string* RemoveServerRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:RemoveServerRequest.region)
  return _s;
}
inline const std::string& RemoveServerRequest::_internal_region() const {
  return _impl_.region_.Get();
}
inline void RemoveServerRequest::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveServerRequest::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveServerRequest::release_region() {
  // @@protoc_insertion_point(field_release:RemoveServerRequest.region)
  return _impl_.region_.Release();
}
inline void RemoveServerRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoveServerRequest.region)
}

// -------------------------------------------------------------------

// ServerInfoList

// repeated .ServerInfo serverInfos = 1;
inline int ServerInfoList::_internal_serverinfos_size() const {
  return _impl_.serverinfos_.size();
}
inline int ServerInfoList::serverinfos_size() const {
  return _internal_serverinfos_size();
}
inline void ServerInfoList::clear_serverinfos() {
  _impl_.serverinfos_.Clear();
}
inline ::ServerInfo* ServerInfoList::mutable_serverinfos(int index) {
  // @@protoc_insertion_point(field_mutable:ServerInfoList.serverInfos)
  return _impl_.serverinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo >*
ServerInfoList::mutable_serverinfos() {
  // @@protoc_insertion_point(field_mutable_list:ServerInfoList.serverInfos)
  return &_impl_.serverinfos_;
}
inline const ::ServerInfo& ServerInfoList::_internal_serverinfos(int index) const {
  return _impl_.serverinfos_.Get(index);
}
inline const ::ServerInfo& ServerInfoList::serverinfos(int index) const {
  // @@protoc_insertion_point(field_get:ServerInfoList.serverInfos)
  return _internal_serverinfos(index);
}
inline ::ServerInfo* ServerInfoList::_internal_add_serverinfos() {
  return _impl_.serverinfos_.Add();
}
inline ::ServerInfo* ServerInfoList::add_serverinfos() {
  ::ServerInfo* _add = _internal_add_serverinfos();
  // @@protoc_insertion_point(field_add:ServerInfoList.serverInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo >&
ServerInfoList::serverinfos() const {
  // @@protoc_insertion_point(field_list:ServerInfoList.serverInfos)
  return _impl_.serverinfos_;
}

// -------------------------------------------------------------------

// PUser

// uint64 aidx = 1;
inline void PUser::clear_aidx() {
  _impl_.aidx_ = uint64_t{0u};
}
inline uint64_t PUser::_internal_aidx() const {
  return _impl_.aidx_;
}
inline uint64_t PUser::aidx() const {
  // @@protoc_insertion_point(field_get:PUser.aidx)
  return _internal_aidx();
}
inline void PUser::_internal_set_aidx(uint64_t value) {
  
  _impl_.aidx_ = value;
}
inline void PUser::set_aidx(uint64_t value) {
  _internal_set_aidx(value);
  // @@protoc_insertion_point(field_set:PUser.aidx)
}

// string name = 2;
inline void PUser::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PUser::name() const {
  // @@protoc_insertion_point(field_get:PUser.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PUser::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PUser.name)
}
inline std::string* PUser::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PUser.name)
  return _s;
}
inline const std::string& PUser::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PUser::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PUser::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PUser::release_name() {
  // @@protoc_insertion_point(field_release:PUser.name)
  return _impl_.name_.Release();
}
inline void PUser::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PUser.name)
}

// string region = 3;
inline void PUser::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& PUser::region() const {
  // @@protoc_insertion_point(field_get:PUser.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PUser::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PUser.region)
}
inline std::string* PUser::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:PUser.region)
  return _s;
}
inline const std::string& PUser::_internal_region() const {
  return _impl_.region_.Get();
}
inline void PUser::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* PUser::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* PUser::release_region() {
  // @@protoc_insertion_point(field_release:PUser.region)
  return _impl_.region_.Release();
}
inline void PUser::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PUser.region)
}

// -------------------------------------------------------------------

// RoomInfo

// uint64 hostAidx = 1;
inline void RoomInfo::clear_hostaidx() {
  _impl_.hostaidx_ = uint64_t{0u};
}
inline uint64_t RoomInfo::_internal_hostaidx() const {
  return _impl_.hostaidx_;
}
inline uint64_t RoomInfo::hostaidx() const {
  // @@protoc_insertion_point(field_get:RoomInfo.hostAidx)
  return _internal_hostaidx();
}
inline void RoomInfo::_internal_set_hostaidx(uint64_t value) {
  
  _impl_.hostaidx_ = value;
}
inline void RoomInfo::set_hostaidx(uint64_t value) {
  _internal_set_hostaidx(value);
  // @@protoc_insertion_point(field_set:RoomInfo.hostAidx)
}

// string title = 2;
inline void RoomInfo::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& RoomInfo::title() const {
  // @@protoc_insertion_point(field_get:RoomInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomInfo.title)
}
inline std::string* RoomInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:RoomInfo.title)
  return _s;
}
inline const std::string& RoomInfo::_internal_title() const {
  return _impl_.title_.Get();
}
inline void RoomInfo::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_title() {
  // @@protoc_insertion_point(field_release:RoomInfo.title)
  return _impl_.title_.Release();
}
inline void RoomInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.title)
}

// uint32 mapId = 3;
inline void RoomInfo::clear_mapid() {
  _impl_.mapid_ = 0u;
}
inline uint32_t RoomInfo::_internal_mapid() const {
  return _impl_.mapid_;
}
inline uint32_t RoomInfo::mapid() const {
  // @@protoc_insertion_point(field_get:RoomInfo.mapId)
  return _internal_mapid();
}
inline void RoomInfo::_internal_set_mapid(uint32_t value) {
  
  _impl_.mapid_ = value;
}
inline void RoomInfo::set_mapid(uint32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:RoomInfo.mapId)
}

// uint32 minMemberCount = 4;
inline void RoomInfo::clear_minmembercount() {
  _impl_.minmembercount_ = 0u;
}
inline uint32_t RoomInfo::_internal_minmembercount() const {
  return _impl_.minmembercount_;
}
inline uint32_t RoomInfo::minmembercount() const {
  // @@protoc_insertion_point(field_get:RoomInfo.minMemberCount)
  return _internal_minmembercount();
}
inline void RoomInfo::_internal_set_minmembercount(uint32_t value) {
  
  _impl_.minmembercount_ = value;
}
inline void RoomInfo::set_minmembercount(uint32_t value) {
  _internal_set_minmembercount(value);
  // @@protoc_insertion_point(field_set:RoomInfo.minMemberCount)
}

// uint32 maxMemberCount = 5;
inline void RoomInfo::clear_maxmembercount() {
  _impl_.maxmembercount_ = 0u;
}
inline uint32_t RoomInfo::_internal_maxmembercount() const {
  return _impl_.maxmembercount_;
}
inline uint32_t RoomInfo::maxmembercount() const {
  // @@protoc_insertion_point(field_get:RoomInfo.maxMemberCount)
  return _internal_maxmembercount();
}
inline void RoomInfo::_internal_set_maxmembercount(uint32_t value) {
  
  _impl_.maxmembercount_ = value;
}
inline void RoomInfo::set_maxmembercount(uint32_t value) {
  _internal_set_maxmembercount(value);
  // @@protoc_insertion_point(field_set:RoomInfo.maxMemberCount)
}

// uint32 nowMemberCount = 6;
inline void RoomInfo::clear_nowmembercount() {
  _impl_.nowmembercount_ = 0u;
}
inline uint32_t RoomInfo::_internal_nowmembercount() const {
  return _impl_.nowmembercount_;
}
inline uint32_t RoomInfo::nowmembercount() const {
  // @@protoc_insertion_point(field_get:RoomInfo.nowMemberCount)
  return _internal_nowmembercount();
}
inline void RoomInfo::_internal_set_nowmembercount(uint32_t value) {
  
  _impl_.nowmembercount_ = value;
}
inline void RoomInfo::set_nowmembercount(uint32_t value) {
  _internal_set_nowmembercount(value);
  // @@protoc_insertion_point(field_set:RoomInfo.nowMemberCount)
}

// uint64 roomId = 7;
inline void RoomInfo::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t RoomInfo::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomId)
  return _internal_roomid();
}
inline void RoomInfo::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void RoomInfo::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomInfo.roomId)
}

// bool locked = 8;
inline void RoomInfo::clear_locked() {
  _impl_.locked_ = false;
}
inline bool RoomInfo::_internal_locked() const {
  return _impl_.locked_;
}
inline bool RoomInfo::locked() const {
  // @@protoc_insertion_point(field_get:RoomInfo.locked)
  return _internal_locked();
}
inline void RoomInfo::_internal_set_locked(bool value) {
  
  _impl_.locked_ = value;
}
inline void RoomInfo::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:RoomInfo.locked)
}

// -------------------------------------------------------------------

// GetRoomListRequest

// string region = 1;
inline void GetRoomListRequest::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& GetRoomListRequest::region() const {
  // @@protoc_insertion_point(field_get:GetRoomListRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRoomListRequest::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRoomListRequest.region)
}
inline std::string* GetRoomListRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:GetRoomListRequest.region)
  return _s;
}
inline const std::string& GetRoomListRequest::_internal_region() const {
  return _impl_.region_.Get();
}
inline void GetRoomListRequest::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRoomListRequest::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRoomListRequest::release_region() {
  // @@protoc_insertion_point(field_release:GetRoomListRequest.region)
  return _impl_.region_.Release();
}
inline void GetRoomListRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRoomListRequest.region)
}

// -------------------------------------------------------------------

// CreateRoomRequest

// string region = 1;
inline void CreateRoomRequest::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::region() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateRoomRequest.region)
}
inline std::string* CreateRoomRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:CreateRoomRequest.region)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_region() const {
  return _impl_.region_.Get();
}
inline void CreateRoomRequest::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_region() {
  // @@protoc_insertion_point(field_release:CreateRoomRequest.region)
  return _impl_.region_.Release();
}
inline void CreateRoomRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateRoomRequest.region)
}

// uint64 hostAidx = 2;
inline void CreateRoomRequest::clear_hostaidx() {
  _impl_.hostaidx_ = uint64_t{0u};
}
inline uint64_t CreateRoomRequest::_internal_hostaidx() const {
  return _impl_.hostaidx_;
}
inline uint64_t CreateRoomRequest::hostaidx() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.hostAidx)
  return _internal_hostaidx();
}
inline void CreateRoomRequest::_internal_set_hostaidx(uint64_t value) {
  
  _impl_.hostaidx_ = value;
}
inline void CreateRoomRequest::set_hostaidx(uint64_t value) {
  _internal_set_hostaidx(value);
  // @@protoc_insertion_point(field_set:CreateRoomRequest.hostAidx)
}

// string title = 3;
inline void CreateRoomRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::title() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateRoomRequest.title)
}
inline std::string* CreateRoomRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CreateRoomRequest.title)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CreateRoomRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_title() {
  // @@protoc_insertion_point(field_release:CreateRoomRequest.title)
  return _impl_.title_.Release();
}
inline void CreateRoomRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateRoomRequest.title)
}

// uint32 mapId = 4;
inline void CreateRoomRequest::clear_mapid() {
  _impl_.mapid_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_mapid() const {
  return _impl_.mapid_;
}
inline uint32_t CreateRoomRequest::mapid() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.mapId)
  return _internal_mapid();
}
inline void CreateRoomRequest::_internal_set_mapid(uint32_t value) {
  
  _impl_.mapid_ = value;
}
inline void CreateRoomRequest::set_mapid(uint32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:CreateRoomRequest.mapId)
}

// uint32 minMemberCount = 5;
inline void CreateRoomRequest::clear_minmembercount() {
  _impl_.minmembercount_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_minmembercount() const {
  return _impl_.minmembercount_;
}
inline uint32_t CreateRoomRequest::minmembercount() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.minMemberCount)
  return _internal_minmembercount();
}
inline void CreateRoomRequest::_internal_set_minmembercount(uint32_t value) {
  
  _impl_.minmembercount_ = value;
}
inline void CreateRoomRequest::set_minmembercount(uint32_t value) {
  _internal_set_minmembercount(value);
  // @@protoc_insertion_point(field_set:CreateRoomRequest.minMemberCount)
}

// uint32 maxMemberCount = 6;
inline void CreateRoomRequest::clear_maxmembercount() {
  _impl_.maxmembercount_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_maxmembercount() const {
  return _impl_.maxmembercount_;
}
inline uint32_t CreateRoomRequest::maxmembercount() const {
  // @@protoc_insertion_point(field_get:CreateRoomRequest.maxMemberCount)
  return _internal_maxmembercount();
}
inline void CreateRoomRequest::_internal_set_maxmembercount(uint32_t value) {
  
  _impl_.maxmembercount_ = value;
}
inline void CreateRoomRequest::set_maxmembercount(uint32_t value) {
  _internal_set_maxmembercount(value);
  // @@protoc_insertion_point(field_set:CreateRoomRequest.maxMemberCount)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// uint64 roomId = 1;
inline void CreateRoomResponse::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomResponse::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t CreateRoomResponse::roomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomResponse.roomId)
  return _internal_roomid();
}
inline void CreateRoomResponse::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void CreateRoomResponse::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:CreateRoomResponse.roomId)
}

// -------------------------------------------------------------------

// CreateRoomTCPRequest

// string region = 1;
inline void CreateRoomTCPRequest::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& CreateRoomTCPRequest::region() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomTCPRequest::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateRoomTCPRequest.region)
}
inline std::string* CreateRoomTCPRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:CreateRoomTCPRequest.region)
  return _s;
}
inline const std::string& CreateRoomTCPRequest::_internal_region() const {
  return _impl_.region_.Get();
}
inline void CreateRoomTCPRequest::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomTCPRequest::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomTCPRequest::release_region() {
  // @@protoc_insertion_point(field_release:CreateRoomTCPRequest.region)
  return _impl_.region_.Release();
}
inline void CreateRoomTCPRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateRoomTCPRequest.region)
}

// uint32 serverId = 2;
inline void CreateRoomTCPRequest::clear_serverid() {
  _impl_.serverid_ = 0u;
}
inline uint32_t CreateRoomTCPRequest::_internal_serverid() const {
  return _impl_.serverid_;
}
inline uint32_t CreateRoomTCPRequest::serverid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPRequest.serverId)
  return _internal_serverid();
}
inline void CreateRoomTCPRequest::_internal_set_serverid(uint32_t value) {
  
  _impl_.serverid_ = value;
}
inline void CreateRoomTCPRequest::set_serverid(uint32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPRequest.serverId)
}

// uint64 roomId = 3;
inline void CreateRoomTCPRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomTCPRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t CreateRoomTCPRequest::roomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPRequest.roomId)
  return _internal_roomid();
}
inline void CreateRoomTCPRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void CreateRoomTCPRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPRequest.roomId)
}

// uint64 tcpRoomId = 4;
inline void CreateRoomTCPRequest::clear_tcproomid() {
  _impl_.tcproomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomTCPRequest::_internal_tcproomid() const {
  return _impl_.tcproomid_;
}
inline uint64_t CreateRoomTCPRequest::tcproomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPRequest.tcpRoomId)
  return _internal_tcproomid();
}
inline void CreateRoomTCPRequest::_internal_set_tcproomid(uint64_t value) {
  
  _impl_.tcproomid_ = value;
}
inline void CreateRoomTCPRequest::set_tcproomid(uint64_t value) {
  _internal_set_tcproomid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPRequest.tcpRoomId)
}

// -------------------------------------------------------------------

// CreateRoomTCPResponse

// uint64 hostAidx = 1;
inline void CreateRoomTCPResponse::clear_hostaidx() {
  _impl_.hostaidx_ = uint64_t{0u};
}
inline uint64_t CreateRoomTCPResponse::_internal_hostaidx() const {
  return _impl_.hostaidx_;
}
inline uint64_t CreateRoomTCPResponse::hostaidx() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.hostAidx)
  return _internal_hostaidx();
}
inline void CreateRoomTCPResponse::_internal_set_hostaidx(uint64_t value) {
  
  _impl_.hostaidx_ = value;
}
inline void CreateRoomTCPResponse::set_hostaidx(uint64_t value) {
  _internal_set_hostaidx(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.hostAidx)
}

// string title = 2;
inline void CreateRoomTCPResponse::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CreateRoomTCPResponse::title() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomTCPResponse::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.title)
}
inline std::string* CreateRoomTCPResponse::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CreateRoomTCPResponse.title)
  return _s;
}
inline const std::string& CreateRoomTCPResponse::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CreateRoomTCPResponse::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomTCPResponse::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomTCPResponse::release_title() {
  // @@protoc_insertion_point(field_release:CreateRoomTCPResponse.title)
  return _impl_.title_.Release();
}
inline void CreateRoomTCPResponse::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CreateRoomTCPResponse.title)
}

// uint32 mapId = 3;
inline void CreateRoomTCPResponse::clear_mapid() {
  _impl_.mapid_ = 0u;
}
inline uint32_t CreateRoomTCPResponse::_internal_mapid() const {
  return _impl_.mapid_;
}
inline uint32_t CreateRoomTCPResponse::mapid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.mapId)
  return _internal_mapid();
}
inline void CreateRoomTCPResponse::_internal_set_mapid(uint32_t value) {
  
  _impl_.mapid_ = value;
}
inline void CreateRoomTCPResponse::set_mapid(uint32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.mapId)
}

// uint32 minMemberCount = 4;
inline void CreateRoomTCPResponse::clear_minmembercount() {
  _impl_.minmembercount_ = 0u;
}
inline uint32_t CreateRoomTCPResponse::_internal_minmembercount() const {
  return _impl_.minmembercount_;
}
inline uint32_t CreateRoomTCPResponse::minmembercount() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.minMemberCount)
  return _internal_minmembercount();
}
inline void CreateRoomTCPResponse::_internal_set_minmembercount(uint32_t value) {
  
  _impl_.minmembercount_ = value;
}
inline void CreateRoomTCPResponse::set_minmembercount(uint32_t value) {
  _internal_set_minmembercount(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.minMemberCount)
}

// uint32 maxMemberCount = 5;
inline void CreateRoomTCPResponse::clear_maxmembercount() {
  _impl_.maxmembercount_ = 0u;
}
inline uint32_t CreateRoomTCPResponse::_internal_maxmembercount() const {
  return _impl_.maxmembercount_;
}
inline uint32_t CreateRoomTCPResponse::maxmembercount() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.maxMemberCount)
  return _internal_maxmembercount();
}
inline void CreateRoomTCPResponse::_internal_set_maxmembercount(uint32_t value) {
  
  _impl_.maxmembercount_ = value;
}
inline void CreateRoomTCPResponse::set_maxmembercount(uint32_t value) {
  _internal_set_maxmembercount(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.maxMemberCount)
}

// uint64 roomId = 6;
inline void CreateRoomTCPResponse::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomTCPResponse::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t CreateRoomTCPResponse::roomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.roomId)
  return _internal_roomid();
}
inline void CreateRoomTCPResponse::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void CreateRoomTCPResponse::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.roomId)
}

// uint64 tcpRoomId = 7;
inline void CreateRoomTCPResponse::clear_tcproomid() {
  _impl_.tcproomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomTCPResponse::_internal_tcproomid() const {
  return _impl_.tcproomid_;
}
inline uint64_t CreateRoomTCPResponse::tcproomid() const {
  // @@protoc_insertion_point(field_get:CreateRoomTCPResponse.tcpRoomId)
  return _internal_tcproomid();
}
inline void CreateRoomTCPResponse::_internal_set_tcproomid(uint64_t value) {
  
  _impl_.tcproomid_ = value;
}
inline void CreateRoomTCPResponse::set_tcproomid(uint64_t value) {
  _internal_set_tcproomid(value);
  // @@protoc_insertion_point(field_set:CreateRoomTCPResponse.tcpRoomId)
}

// -------------------------------------------------------------------

// RemoveRoomTCPRequest

// uint64 roomId = 1;
inline void RemoveRoomTCPRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t RemoveRoomTCPRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t RemoveRoomTCPRequest::roomid() const {
  // @@protoc_insertion_point(field_get:RemoveRoomTCPRequest.roomId)
  return _internal_roomid();
}
inline void RemoveRoomTCPRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void RemoveRoomTCPRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RemoveRoomTCPRequest.roomId)
}

// -------------------------------------------------------------------

// EnterRoomRequest

// uint64 aidx = 1;
inline void EnterRoomRequest::clear_aidx() {
  _impl_.aidx_ = uint64_t{0u};
}
inline uint64_t EnterRoomRequest::_internal_aidx() const {
  return _impl_.aidx_;
}
inline uint64_t EnterRoomRequest::aidx() const {
  // @@protoc_insertion_point(field_get:EnterRoomRequest.aidx)
  return _internal_aidx();
}
inline void EnterRoomRequest::_internal_set_aidx(uint64_t value) {
  
  _impl_.aidx_ = value;
}
inline void EnterRoomRequest::set_aidx(uint64_t value) {
  _internal_set_aidx(value);
  // @@protoc_insertion_point(field_set:EnterRoomRequest.aidx)
}

// string name = 2;
inline void EnterRoomRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EnterRoomRequest::name() const {
  // @@protoc_insertion_point(field_get:EnterRoomRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterRoomRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EnterRoomRequest.name)
}
inline std::string* EnterRoomRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:EnterRoomRequest.name)
  return _s;
}
inline const std::string& EnterRoomRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EnterRoomRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnterRoomRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnterRoomRequest::release_name() {
  // @@protoc_insertion_point(field_release:EnterRoomRequest.name)
  return _impl_.name_.Release();
}
inline void EnterRoomRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EnterRoomRequest.name)
}

// string region = 3;
inline void EnterRoomRequest::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& EnterRoomRequest::region() const {
  // @@protoc_insertion_point(field_get:EnterRoomRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterRoomRequest::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EnterRoomRequest.region)
}
inline std::string* EnterRoomRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:EnterRoomRequest.region)
  return _s;
}
inline const std::string& EnterRoomRequest::_internal_region() const {
  return _impl_.region_.Get();
}
inline void EnterRoomRequest::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* EnterRoomRequest::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* EnterRoomRequest::release_region() {
  // @@protoc_insertion_point(field_release:EnterRoomRequest.region)
  return _impl_.region_.Release();
}
inline void EnterRoomRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EnterRoomRequest.region)
}

// uint64 roomId = 4;
inline void EnterRoomRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t EnterRoomRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t EnterRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:EnterRoomRequest.roomId)
  return _internal_roomid();
}
inline void EnterRoomRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void EnterRoomRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:EnterRoomRequest.roomId)
}

// -------------------------------------------------------------------

// EnterRoomResponse

// bool success = 1;
inline void EnterRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool EnterRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool EnterRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.success)
  return _internal_success();
}
inline void EnterRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void EnterRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:EnterRoomResponse.success)
}

// string message = 2;
inline void EnterRoomResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EnterRoomResponse::message() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterRoomResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EnterRoomResponse.message)
}
inline std::string* EnterRoomResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:EnterRoomResponse.message)
  return _s;
}
inline const std::string& EnterRoomResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EnterRoomResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EnterRoomResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* EnterRoomResponse::release_message() {
  // @@protoc_insertion_point(field_release:EnterRoomResponse.message)
  return _impl_.message_.Release();
}
inline void EnterRoomResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EnterRoomResponse.message)
}

// string host = 3;
inline void EnterRoomResponse::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& EnterRoomResponse::host() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterRoomResponse::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EnterRoomResponse.host)
}
inline std::string* EnterRoomResponse::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:EnterRoomResponse.host)
  return _s;
}
inline const std::string& EnterRoomResponse::_internal_host() const {
  return _impl_.host_.Get();
}
inline void EnterRoomResponse::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* EnterRoomResponse::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* EnterRoomResponse::release_host() {
  // @@protoc_insertion_point(field_release:EnterRoomResponse.host)
  return _impl_.host_.Release();
}
inline void EnterRoomResponse::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EnterRoomResponse.host)
}

// uint32 port = 4;
inline void EnterRoomResponse::clear_port() {
  _impl_.port_ = 0u;
}
inline uint32_t EnterRoomResponse::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t EnterRoomResponse::port() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.port)
  return _internal_port();
}
inline void EnterRoomResponse::_internal_set_port(uint32_t value) {
  
  _impl_.port_ = value;
}
inline void EnterRoomResponse::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:EnterRoomResponse.port)
}

// uint64 tcpRoomId = 5;
inline void EnterRoomResponse::clear_tcproomid() {
  _impl_.tcproomid_ = uint64_t{0u};
}
inline uint64_t EnterRoomResponse::_internal_tcproomid() const {
  return _impl_.tcproomid_;
}
inline uint64_t EnterRoomResponse::tcproomid() const {
  // @@protoc_insertion_point(field_get:EnterRoomResponse.tcpRoomId)
  return _internal_tcproomid();
}
inline void EnterRoomResponse::_internal_set_tcproomid(uint64_t value) {
  
  _impl_.tcproomid_ = value;
}
inline void EnterRoomResponse::set_tcproomid(uint64_t value) {
  _internal_set_tcproomid(value);
  // @@protoc_insertion_point(field_set:EnterRoomResponse.tcpRoomId)
}

// -------------------------------------------------------------------

// LeaveRoomRequest

// uint64 aidx = 1;
inline void LeaveRoomRequest::clear_aidx() {
  _impl_.aidx_ = uint64_t{0u};
}
inline uint64_t LeaveRoomRequest::_internal_aidx() const {
  return _impl_.aidx_;
}
inline uint64_t LeaveRoomRequest::aidx() const {
  // @@protoc_insertion_point(field_get:LeaveRoomRequest.aidx)
  return _internal_aidx();
}
inline void LeaveRoomRequest::_internal_set_aidx(uint64_t value) {
  
  _impl_.aidx_ = value;
}
inline void LeaveRoomRequest::set_aidx(uint64_t value) {
  _internal_set_aidx(value);
  // @@protoc_insertion_point(field_set:LeaveRoomRequest.aidx)
}

// uint64 roomId = 2;
inline void LeaveRoomRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t LeaveRoomRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t LeaveRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:LeaveRoomRequest.roomId)
  return _internal_roomid();
}
inline void LeaveRoomRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void LeaveRoomRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:LeaveRoomRequest.roomId)
}

// -------------------------------------------------------------------

// StartGameRequest

// uint64 hostAidx = 1;
inline void StartGameRequest::clear_hostaidx() {
  _impl_.hostaidx_ = uint64_t{0u};
}
inline uint64_t StartGameRequest::_internal_hostaidx() const {
  return _impl_.hostaidx_;
}
inline uint64_t StartGameRequest::hostaidx() const {
  // @@protoc_insertion_point(field_get:StartGameRequest.hostAidx)
  return _internal_hostaidx();
}
inline void StartGameRequest::_internal_set_hostaidx(uint64_t value) {
  
  _impl_.hostaidx_ = value;
}
inline void StartGameRequest::set_hostaidx(uint64_t value) {
  _internal_set_hostaidx(value);
  // @@protoc_insertion_point(field_set:StartGameRequest.hostAidx)
}

// uint64 roomId = 2;
inline void StartGameRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t StartGameRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t StartGameRequest::roomid() const {
  // @@protoc_insertion_point(field_get:StartGameRequest.roomId)
  return _internal_roomid();
}
inline void StartGameRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void StartGameRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:StartGameRequest.roomId)
}

// -------------------------------------------------------------------

// GetRoomListResponse

// repeated .RoomInfo roomInfos = 1;
inline int GetRoomListResponse::_internal_roominfos_size() const {
  return _impl_.roominfos_.size();
}
inline int GetRoomListResponse::roominfos_size() const {
  return _internal_roominfos_size();
}
inline void GetRoomListResponse::clear_roominfos() {
  _impl_.roominfos_.Clear();
}
inline ::RoomInfo* GetRoomListResponse::mutable_roominfos(int index) {
  // @@protoc_insertion_point(field_mutable:GetRoomListResponse.roomInfos)
  return _impl_.roominfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >*
GetRoomListResponse::mutable_roominfos() {
  // @@protoc_insertion_point(field_mutable_list:GetRoomListResponse.roomInfos)
  return &_impl_.roominfos_;
}
inline const ::RoomInfo& GetRoomListResponse::_internal_roominfos(int index) const {
  return _impl_.roominfos_.Get(index);
}
inline const ::RoomInfo& GetRoomListResponse::roominfos(int index) const {
  // @@protoc_insertion_point(field_get:GetRoomListResponse.roomInfos)
  return _internal_roominfos(index);
}
inline ::RoomInfo* GetRoomListResponse::_internal_add_roominfos() {
  return _impl_.roominfos_.Add();
}
inline ::RoomInfo* GetRoomListResponse::add_roominfos() {
  ::RoomInfo* _add = _internal_add_roominfos();
  // @@protoc_insertion_point(field_add:GetRoomListResponse.roomInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >&
GetRoomListResponse::roominfos() const {
  // @@protoc_insertion_point(field_list:GetRoomListResponse.roomInfos)
  return _impl_.roominfos_;
}

// -------------------------------------------------------------------

// RoomList

// repeated .RoomInfo roomInfos = 1;
inline int RoomList::_internal_roominfos_size() const {
  return _impl_.roominfos_.size();
}
inline int RoomList::roominfos_size() const {
  return _internal_roominfos_size();
}
inline void RoomList::clear_roominfos() {
  _impl_.roominfos_.Clear();
}
inline ::RoomInfo* RoomList::mutable_roominfos(int index) {
  // @@protoc_insertion_point(field_mutable:RoomList.roomInfos)
  return _impl_.roominfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >*
RoomList::mutable_roominfos() {
  // @@protoc_insertion_point(field_mutable_list:RoomList.roomInfos)
  return &_impl_.roominfos_;
}
inline const ::RoomInfo& RoomList::_internal_roominfos(int index) const {
  return _impl_.roominfos_.Get(index);
}
inline const ::RoomInfo& RoomList::roominfos(int index) const {
  // @@protoc_insertion_point(field_get:RoomList.roomInfos)
  return _internal_roominfos(index);
}
inline ::RoomInfo* RoomList::_internal_add_roominfos() {
  return _impl_.roominfos_.Add();
}
inline ::RoomInfo* RoomList::add_roominfos() {
  ::RoomInfo* _add = _internal_add_roominfos();
  // @@protoc_insertion_point(field_add:RoomList.roomInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomInfo >&
RoomList::roominfos() const {
  // @@protoc_insertion_point(field_list:RoomList.roomInfos)
  return _impl_.roominfos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_match_2eproto
