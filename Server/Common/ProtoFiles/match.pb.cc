// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: match.proto

#include "match.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized) {}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
PROTOBUF_CONSTEXPR ServerInfo::ServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.roomlist_)*/nullptr
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerInfoDefaultTypeInternal() {}
  union {
    ServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
PROTOBUF_CONSTEXPR ServerInfoList::ServerInfoList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.servers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServerInfoListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerInfoListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerInfoListDefaultTypeInternal() {}
  union {
    ServerInfoList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerInfoListDefaultTypeInternal _ServerInfoList_default_instance_;
PROTOBUF_CONSTEXPR User::User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.aidx_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ishost_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_CONSTEXPR Room::Room(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.membercount_)*/0
  , /*decltype(_impl_.minmembercount_)*/0
  , /*decltype(_impl_.maxmembercount_)*/0
  , /*decltype(_impl_.mapid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoomDefaultTypeInternal() {}
  union {
    Room _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoomDefaultTypeInternal _Room_default_instance_;
PROTOBUF_CONSTEXPR CreatedRoomInfo::CreatedRoomInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/nullptr
  , /*decltype(_impl_.mapid_)*/0
  , /*decltype(_impl_.minmembercount_)*/0
  , /*decltype(_impl_.maxmembercount_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreatedRoomInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreatedRoomInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreatedRoomInfoDefaultTypeInternal() {}
  union {
    CreatedRoomInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreatedRoomInfoDefaultTypeInternal _CreatedRoomInfo_default_instance_;
PROTOBUF_CONSTEXPR EnteredRoomInfo::EnteredRoomInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnteredRoomInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnteredRoomInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnteredRoomInfoDefaultTypeInternal() {}
  union {
    EnteredRoomInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnteredRoomInfoDefaultTypeInternal _EnteredRoomInfo_default_instance_;
PROTOBUF_CONSTEXPR DetailedRoom::DetailedRoom(
    ::_pbi::ConstantInitialized) {}
struct DetailedRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailedRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailedRoomDefaultTypeInternal() {}
  union {
    DetailedRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailedRoomDefaultTypeInternal _DetailedRoom_default_instance_;
PROTOBUF_CONSTEXPR RoomList::RoomList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.room_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoomListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoomListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoomListDefaultTypeInternal() {}
  union {
    RoomList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoomListDefaultTypeInternal _RoomList_default_instance_;
static ::_pb::Metadata file_level_metadata_match_2eproto[9];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_match_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_match_2eproto = nullptr;

const uint32_t TableStruct_match_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ServerInfo, _impl_.host_),
  PROTOBUF_FIELD_OFFSET(::ServerInfo, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::ServerInfo, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::ServerInfo, _impl_.roomlist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ServerInfoList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ServerInfoList, _impl_.servers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::User, _impl_.aidx_),
  PROTOBUF_FIELD_OFFSET(::User, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::User, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::User, _impl_.ishost_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Room, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.membercount_),
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.minmembercount_),
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.maxmembercount_),
  PROTOBUF_FIELD_OFFSET(::Room, _impl_.mapid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _impl_.mapid_),
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _impl_.minmembercount_),
  PROTOBUF_FIELD_OFFSET(::CreatedRoomInfo, _impl_.maxmembercount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::EnteredRoomInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::EnteredRoomInfo, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::EnteredRoomInfo, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DetailedRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RoomList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RoomList, _impl_.room_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Empty)},
  { 6, -1, -1, sizeof(::ServerInfo)},
  { 16, -1, -1, sizeof(::ServerInfoList)},
  { 23, -1, -1, sizeof(::User)},
  { 33, -1, -1, sizeof(::Room)},
  { 45, -1, -1, sizeof(::CreatedRoomInfo)},
  { 56, -1, -1, sizeof(::EnteredRoomInfo)},
  { 64, -1, -1, sizeof(::DetailedRoom)},
  { 70, -1, -1, sizeof(::RoomList)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_Empty_default_instance_._instance,
  &::_ServerInfo_default_instance_._instance,
  &::_ServerInfoList_default_instance_._instance,
  &::_User_default_instance_._instance,
  &::_Room_default_instance_._instance,
  &::_CreatedRoomInfo_default_instance_._instance,
  &::_EnteredRoomInfo_default_instance_._instance,
  &::_DetailedRoom_default_instance_._instance,
  &::_RoomList_default_instance_._instance,
};

const char descriptor_table_protodef_match_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013match.proto\"\007\n\005Empty\"U\n\nServerInfo\022\014\n\004"
  "host\030\001 \001(\t\022\014\n\004port\030\002 \001(\005\022\016\n\006region\030\003 \001(\t"
  "\022\033\n\010roomList\030\004 \001(\0132\t.RoomList\".\n\016ServerI"
  "nfoList\022\034\n\007servers\030\001 \003(\0132\013.ServerInfo\"B\n"
  "\004User\022\014\n\004aidx\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\016\n\006reg"
  "ion\030\003 \001(\t\022\016\n\006isHost\030\004 \001(\005\"u\n\004Room\022\013\n\003key"
  "\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\023\n\013memberCount\030\003 \001("
  "\005\022\026\n\016minMemberCount\030\004 \001(\005\022\026\n\016maxMemberCo"
  "unt\030\005 \001(\005\022\r\n\005mapId\030\006 \001(\005\"s\n\017CreatedRoomI"
  "nfo\022\023\n\004user\030\001 \001(\0132\005.User\022\014\n\004name\030\002 \001(\t\022\r"
  "\n\005mapId\030\003 \001(\005\022\026\n\016minMemberCount\030\004 \001(\005\022\026\n"
  "\016maxMemberCount\030\005 \001(\005\"3\n\017EnteredRoomInfo"
  "\022\023\n\004user\030\001 \001(\0132\005.User\022\013\n\003key\030\002 \001(\t\"\016\n\014De"
  "tailedRoom\"\037\n\010RoomList\022\023\n\004room\030\001 \003(\0132\005.R"
  "oom2\326\002\n\014MatchService\022!\n\013GetRoomList\022\005.Us"
  "er\032\t.RoomList\"\000\022\'\n\nCreateRoom\022\020.CreatedR"
  "oomInfo\032\005.Room\"\000\022\'\n\tEnterRoom\022\020.EnteredR"
  "oomInfo\032\006.Empty\"\000\022\034\n\tLeaveRoom\022\005.User\032\006."
  "Empty\"\000\022\034\n\tStartGame\022\005.User\032\006.Empty\"\000\022\'\n"
  "\tEnterUser\022\020.EnteredRoomInfo\032\006.Empty\"\000\022\034"
  "\n\tLeaveUser\022\005.User\032\006.Empty\"\000\022*\n\rCreateRo"
  "omTCP\022\020.CreatedRoomInfo\032\005.Room\"\000\022\"\n\tAddS"
  "erver\022\013.ServerInfo\032\006.Empty\"\000b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_match_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_match_2eproto = {
    false, false, 916, descriptor_table_protodef_match_2eproto,
    "match.proto",
    &descriptor_table_match_2eproto_once, nullptr, 0, 9,
    schemas, file_default_instances, TableStruct_match_2eproto::offsets,
    file_level_metadata_match_2eproto, file_level_enum_descriptors_match_2eproto,
    file_level_service_descriptors_match_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_match_2eproto_getter() {
  return &descriptor_table_match_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_match_2eproto(&descriptor_table_match_2eproto);

// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Empty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[0]);
}

// ===================================================================

class ServerInfo::_Internal {
 public:
  static const ::RoomList& roomlist(const ServerInfo* msg);
};

const ::RoomList&
ServerInfo::_Internal::roomlist(const ServerInfo* msg) {
  return *msg->_impl_.roomlist_;
}
ServerInfo::ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ServerInfo)
}
ServerInfo::ServerInfo(const ServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.roomlist_){nullptr}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host().empty()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_region().empty()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_roomlist()) {
    _this->_impl_.roomlist_ = new ::RoomList(*from._impl_.roomlist_);
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:ServerInfo)
}

inline void ServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.roomlist_){nullptr}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServerInfo::~ServerInfo() {
  // @@protoc_insertion_point(destructor:ServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_.Destroy();
  _impl_.region_.Destroy();
  if (this != internal_default_instance()) delete _impl_.roomlist_;
}

void ServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_.ClearToEmpty();
  _impl_.region_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.roomlist_ != nullptr) {
    delete _impl_.roomlist_;
  }
  _impl_.roomlist_ = nullptr;
  _impl_.port_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string host = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ServerInfo.host"));
        } else
          goto handle_unusual;
        continue;
      // int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ServerInfo.region"));
        } else
          goto handle_unusual;
        continue;
      // .RoomList roomList = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_roomlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string host = 1;
  if (!this->_internal_host().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ServerInfo.host");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_host(), target);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  // string region = 3;
  if (!this->_internal_region().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_region().data(), static_cast<int>(this->_internal_region().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ServerInfo.region");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_region(), target);
  }

  // .RoomList roomList = 4;
  if (this->_internal_has_roomlist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::roomlist(this),
        _Internal::roomlist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ServerInfo)
  return target;
}

size_t ServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string host = 1;
  if (!this->_internal_host().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host());
  }

  // string region = 3;
  if (!this->_internal_region().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_region());
  }

  // .RoomList roomList = 4;
  if (this->_internal_has_roomlist()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.roomlist_);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerInfo::GetClassData() const { return &_class_data_; }


void ServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerInfo*>(&to_msg);
  auto& from = static_cast<const ServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_host().empty()) {
    _this->_internal_set_host(from._internal_host());
  }
  if (!from._internal_region().empty()) {
    _this->_internal_set_region(from._internal_region());
  }
  if (from._internal_has_roomlist()) {
    _this->_internal_mutable_roomlist()->::RoomList::MergeFrom(
        from._internal_roomlist());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerInfo::CopyFrom(const ServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerInfo::IsInitialized() const {
  return true;
}

void ServerInfo::InternalSwap(ServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerInfo, _impl_.port_)
      + sizeof(ServerInfo::_impl_.port_)
      - PROTOBUF_FIELD_OFFSET(ServerInfo, _impl_.roomlist_)>(
          reinterpret_cast<char*>(&_impl_.roomlist_),
          reinterpret_cast<char*>(&other->_impl_.roomlist_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[1]);
}

// ===================================================================

class ServerInfoList::_Internal {
 public:
};

ServerInfoList::ServerInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ServerInfoList)
}
ServerInfoList::ServerInfoList(const ServerInfoList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServerInfoList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){from._impl_.servers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ServerInfoList)
}

inline void ServerInfoList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.servers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServerInfoList::~ServerInfoList() {
  // @@protoc_insertion_point(destructor:ServerInfoList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerInfoList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.servers_.~RepeatedPtrField();
}

void ServerInfoList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerInfoList::Clear() {
// @@protoc_insertion_point(message_clear_start:ServerInfoList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.servers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerInfoList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ServerInfo servers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_servers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerInfoList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ServerInfoList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ServerInfo servers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_servers_size()); i < n; i++) {
    const auto& repfield = this->_internal_servers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ServerInfoList)
  return target;
}

size_t ServerInfoList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ServerInfoList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ServerInfo servers = 1;
  total_size += 1UL * this->_internal_servers_size();
  for (const auto& msg : this->_impl_.servers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerInfoList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServerInfoList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerInfoList::GetClassData() const { return &_class_data_; }


void ServerInfoList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServerInfoList*>(&to_msg);
  auto& from = static_cast<const ServerInfoList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ServerInfoList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.servers_.MergeFrom(from._impl_.servers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerInfoList::CopyFrom(const ServerInfoList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ServerInfoList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerInfoList::IsInitialized() const {
  return true;
}

void ServerInfoList::InternalSwap(ServerInfoList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.servers_.InternalSwap(&other->_impl_.servers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerInfoList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[2]);
}

// ===================================================================

class User::_Internal {
 public:
};

User::User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:User)
}
User::User(const User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.aidx_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.ishost_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.aidx_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.aidx_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_aidx().empty()) {
    _this->_impl_.aidx_.Set(from._internal_aidx(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_region().empty()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.ishost_ = from._impl_.ishost_;
  // @@protoc_insertion_point(copy_constructor:User)
}

inline void User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.aidx_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.ishost_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.aidx_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.aidx_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

User::~User() {
  // @@protoc_insertion_point(destructor:User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.aidx_.Destroy();
  _impl_.name_.Destroy();
  _impl_.region_.Destroy();
}

void User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void User::Clear() {
// @@protoc_insertion_point(message_clear_start:User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.aidx_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.region_.ClearToEmpty();
  _impl_.ishost_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string aidx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_aidx();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "User.aidx"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "User.name"));
        } else
          goto handle_unusual;
        continue;
      // string region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "User.region"));
        } else
          goto handle_unusual;
        continue;
      // int32 isHost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.ishost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string aidx = 1;
  if (!this->_internal_aidx().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_aidx().data(), static_cast<int>(this->_internal_aidx().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "User.aidx");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_aidx(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "User.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string region = 3;
  if (!this->_internal_region().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_region().data(), static_cast<int>(this->_internal_region().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "User.region");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_region(), target);
  }

  // int32 isHost = 4;
  if (this->_internal_ishost() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_ishost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:User)
  return target;
}

size_t User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string aidx = 1;
  if (!this->_internal_aidx().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_aidx());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string region = 3;
  if (!this->_internal_region().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_region());
  }

  // int32 isHost = 4;
  if (this->_internal_ishost() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ishost());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*User::GetClassData() const { return &_class_data_; }


void User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<User*>(&to_msg);
  auto& from = static_cast<const User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_aidx().empty()) {
    _this->_internal_set_aidx(from._internal_aidx());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_region().empty()) {
    _this->_internal_set_region(from._internal_region());
  }
  if (from._internal_ishost() != 0) {
    _this->_internal_set_ishost(from._internal_ishost());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  return true;
}

void User::InternalSwap(User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.aidx_, lhs_arena,
      &other->_impl_.aidx_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
  swap(_impl_.ishost_, other->_impl_.ishost_);
}

::PROTOBUF_NAMESPACE_ID::Metadata User::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[3]);
}

// ===================================================================

class Room::_Internal {
 public:
};

Room::Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Room)
}
Room::Room(const Room& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Room* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.membercount_){}
    , decltype(_impl_.minmembercount_){}
    , decltype(_impl_.maxmembercount_){}
    , decltype(_impl_.mapid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.membercount_, &from._impl_.membercount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mapid_) -
    reinterpret_cast<char*>(&_impl_.membercount_)) + sizeof(_impl_.mapid_));
  // @@protoc_insertion_point(copy_constructor:Room)
}

inline void Room::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.membercount_){0}
    , decltype(_impl_.minmembercount_){0}
    , decltype(_impl_.maxmembercount_){0}
    , decltype(_impl_.mapid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Room::~Room() {
  // @@protoc_insertion_point(destructor:Room)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.name_.Destroy();
}

void Room::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room::Clear() {
// @@protoc_insertion_point(message_clear_start:Room)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.membercount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mapid_) -
      reinterpret_cast<char*>(&_impl_.membercount_)) + sizeof(_impl_.mapid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Room::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Room.key"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Room.name"));
        } else
          goto handle_unusual;
        continue;
      // int32 memberCount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.membercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 minMemberCount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.minmembercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxMemberCount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.maxmembercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 mapId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.mapid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Room)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Room.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Room.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // int32 memberCount = 3;
  if (this->_internal_membercount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_membercount(), target);
  }

  // int32 minMemberCount = 4;
  if (this->_internal_minmembercount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_minmembercount(), target);
  }

  // int32 maxMemberCount = 5;
  if (this->_internal_maxmembercount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_maxmembercount(), target);
  }

  // int32 mapId = 6;
  if (this->_internal_mapid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_mapid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Room)
  return target;
}

size_t Room::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Room)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int32 memberCount = 3;
  if (this->_internal_membercount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_membercount());
  }

  // int32 minMemberCount = 4;
  if (this->_internal_minmembercount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minmembercount());
  }

  // int32 maxMemberCount = 5;
  if (this->_internal_maxmembercount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxmembercount());
  }

  // int32 mapId = 6;
  if (this->_internal_mapid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mapid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Room::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Room::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Room::GetClassData() const { return &_class_data_; }


void Room::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Room*>(&to_msg);
  auto& from = static_cast<const Room&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Room)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_membercount() != 0) {
    _this->_internal_set_membercount(from._internal_membercount());
  }
  if (from._internal_minmembercount() != 0) {
    _this->_internal_set_minmembercount(from._internal_minmembercount());
  }
  if (from._internal_maxmembercount() != 0) {
    _this->_internal_set_maxmembercount(from._internal_maxmembercount());
  }
  if (from._internal_mapid() != 0) {
    _this->_internal_set_mapid(from._internal_mapid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Room::CopyFrom(const Room& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Room)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room::IsInitialized() const {
  return true;
}

void Room::InternalSwap(Room* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Room, _impl_.mapid_)
      + sizeof(Room::_impl_.mapid_)
      - PROTOBUF_FIELD_OFFSET(Room, _impl_.membercount_)>(
          reinterpret_cast<char*>(&_impl_.membercount_),
          reinterpret_cast<char*>(&other->_impl_.membercount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Room::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[4]);
}

// ===================================================================

class CreatedRoomInfo::_Internal {
 public:
  static const ::User& user(const CreatedRoomInfo* msg);
};

const ::User&
CreatedRoomInfo::_Internal::user(const CreatedRoomInfo* msg) {
  return *msg->_impl_.user_;
}
CreatedRoomInfo::CreatedRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CreatedRoomInfo)
}
CreatedRoomInfo::CreatedRoomInfo(const CreatedRoomInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreatedRoomInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.user_){nullptr}
    , decltype(_impl_.mapid_){}
    , decltype(_impl_.minmembercount_){}
    , decltype(_impl_.maxmembercount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_user()) {
    _this->_impl_.user_ = new ::User(*from._impl_.user_);
  }
  ::memcpy(&_impl_.mapid_, &from._impl_.mapid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maxmembercount_) -
    reinterpret_cast<char*>(&_impl_.mapid_)) + sizeof(_impl_.maxmembercount_));
  // @@protoc_insertion_point(copy_constructor:CreatedRoomInfo)
}

inline void CreatedRoomInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.user_){nullptr}
    , decltype(_impl_.mapid_){0}
    , decltype(_impl_.minmembercount_){0}
    , decltype(_impl_.maxmembercount_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreatedRoomInfo::~CreatedRoomInfo() {
  // @@protoc_insertion_point(destructor:CreatedRoomInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreatedRoomInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.user_;
}

void CreatedRoomInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreatedRoomInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CreatedRoomInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
  ::memset(&_impl_.mapid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maxmembercount_) -
      reinterpret_cast<char*>(&_impl_.mapid_)) + sizeof(_impl_.maxmembercount_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreatedRoomInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CreatedRoomInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // int32 mapId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.mapid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 minMemberCount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.minmembercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 maxMemberCount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.maxmembercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreatedRoomInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CreatedRoomInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .User user = 1;
  if (this->_internal_has_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user(this),
        _Internal::user(this).GetCachedSize(), target, stream);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CreatedRoomInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // int32 mapId = 3;
  if (this->_internal_mapid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mapid(), target);
  }

  // int32 minMemberCount = 4;
  if (this->_internal_minmembercount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_minmembercount(), target);
  }

  // int32 maxMemberCount = 5;
  if (this->_internal_maxmembercount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_maxmembercount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CreatedRoomInfo)
  return target;
}

size_t CreatedRoomInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CreatedRoomInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .User user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_);
  }

  // int32 mapId = 3;
  if (this->_internal_mapid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mapid());
  }

  // int32 minMemberCount = 4;
  if (this->_internal_minmembercount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minmembercount());
  }

  // int32 maxMemberCount = 5;
  if (this->_internal_maxmembercount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxmembercount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreatedRoomInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreatedRoomInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreatedRoomInfo::GetClassData() const { return &_class_data_; }


void CreatedRoomInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreatedRoomInfo*>(&to_msg);
  auto& from = static_cast<const CreatedRoomInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CreatedRoomInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_user()) {
    _this->_internal_mutable_user()->::User::MergeFrom(
        from._internal_user());
  }
  if (from._internal_mapid() != 0) {
    _this->_internal_set_mapid(from._internal_mapid());
  }
  if (from._internal_minmembercount() != 0) {
    _this->_internal_set_minmembercount(from._internal_minmembercount());
  }
  if (from._internal_maxmembercount() != 0) {
    _this->_internal_set_maxmembercount(from._internal_maxmembercount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreatedRoomInfo::CopyFrom(const CreatedRoomInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CreatedRoomInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreatedRoomInfo::IsInitialized() const {
  return true;
}

void CreatedRoomInfo::InternalSwap(CreatedRoomInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreatedRoomInfo, _impl_.maxmembercount_)
      + sizeof(CreatedRoomInfo::_impl_.maxmembercount_)
      - PROTOBUF_FIELD_OFFSET(CreatedRoomInfo, _impl_.user_)>(
          reinterpret_cast<char*>(&_impl_.user_),
          reinterpret_cast<char*>(&other->_impl_.user_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreatedRoomInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[5]);
}

// ===================================================================

class EnteredRoomInfo::_Internal {
 public:
  static const ::User& user(const EnteredRoomInfo* msg);
};

const ::User&
EnteredRoomInfo::_Internal::user(const EnteredRoomInfo* msg) {
  return *msg->_impl_.user_;
}
EnteredRoomInfo::EnteredRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:EnteredRoomInfo)
}
EnteredRoomInfo::EnteredRoomInfo(const EnteredRoomInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnteredRoomInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.user_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_user()) {
    _this->_impl_.user_ = new ::User(*from._impl_.user_);
  }
  // @@protoc_insertion_point(copy_constructor:EnteredRoomInfo)
}

inline void EnteredRoomInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.user_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EnteredRoomInfo::~EnteredRoomInfo() {
  // @@protoc_insertion_point(destructor:EnteredRoomInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnteredRoomInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.user_;
}

void EnteredRoomInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnteredRoomInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:EnteredRoomInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnteredRoomInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "EnteredRoomInfo.key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnteredRoomInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EnteredRoomInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .User user = 1;
  if (this->_internal_has_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user(this),
        _Internal::user(this).GetCachedSize(), target, stream);
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "EnteredRoomInfo.key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EnteredRoomInfo)
  return target;
}

size_t EnteredRoomInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EnteredRoomInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // .User user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnteredRoomInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnteredRoomInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnteredRoomInfo::GetClassData() const { return &_class_data_; }


void EnteredRoomInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnteredRoomInfo*>(&to_msg);
  auto& from = static_cast<const EnteredRoomInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:EnteredRoomInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_has_user()) {
    _this->_internal_mutable_user()->::User::MergeFrom(
        from._internal_user());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnteredRoomInfo::CopyFrom(const EnteredRoomInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EnteredRoomInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnteredRoomInfo::IsInitialized() const {
  return true;
}

void EnteredRoomInfo::InternalSwap(EnteredRoomInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.user_, other->_impl_.user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EnteredRoomInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[6]);
}

// ===================================================================

class DetailedRoom::_Internal {
 public:
};

DetailedRoom::DetailedRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:DetailedRoom)
}
DetailedRoom::DetailedRoom(const DetailedRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DetailedRoom* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DetailedRoom)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetailedRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetailedRoom::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DetailedRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[7]);
}

// ===================================================================

class RoomList::_Internal {
 public:
};

RoomList::RoomList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RoomList)
}
RoomList::RoomList(const RoomList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RoomList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.room_){from._impl_.room_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:RoomList)
}

inline void RoomList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.room_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RoomList::~RoomList() {
  // @@protoc_insertion_point(destructor:RoomList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoomList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.room_.~RepeatedPtrField();
}

void RoomList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RoomList::Clear() {
// @@protoc_insertion_point(message_clear_start:RoomList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.room_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoomList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Room room = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_room(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoomList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RoomList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Room room = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_room_size()); i < n; i++) {
    const auto& repfield = this->_internal_room(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RoomList)
  return target;
}

size_t RoomList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RoomList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Room room = 1;
  total_size += 1UL * this->_internal_room_size();
  for (const auto& msg : this->_impl_.room_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoomList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RoomList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoomList::GetClassData() const { return &_class_data_; }


void RoomList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RoomList*>(&to_msg);
  auto& from = static_cast<const RoomList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RoomList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.room_.MergeFrom(from._impl_.room_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoomList::CopyFrom(const RoomList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RoomList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomList::IsInitialized() const {
  return true;
}

void RoomList::InternalSwap(RoomList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.room_.InternalSwap(&other->_impl_.room_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RoomList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_match_2eproto_getter, &descriptor_table_match_2eproto_once,
      file_level_metadata_match_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Empty*
Arena::CreateMaybeMessage< ::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::ServerInfo*
Arena::CreateMaybeMessage< ::ServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ServerInfoList*
Arena::CreateMaybeMessage< ::ServerInfoList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ServerInfoList >(arena);
}
template<> PROTOBUF_NOINLINE ::User*
Arena::CreateMaybeMessage< ::User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::User >(arena);
}
template<> PROTOBUF_NOINLINE ::Room*
Arena::CreateMaybeMessage< ::Room >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Room >(arena);
}
template<> PROTOBUF_NOINLINE ::CreatedRoomInfo*
Arena::CreateMaybeMessage< ::CreatedRoomInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CreatedRoomInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::EnteredRoomInfo*
Arena::CreateMaybeMessage< ::EnteredRoomInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EnteredRoomInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::DetailedRoom*
Arena::CreateMaybeMessage< ::DetailedRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DetailedRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::RoomList*
Arena::CreateMaybeMessage< ::RoomList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RoomList >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
